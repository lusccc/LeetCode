## 101. Symmetric Tree
Difficulty: Easy  
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3
```
Note:
Bonus points if you could solve it both recursively and iteratively.

#### æˆ‘çš„è§£æ³•
æˆ‘ä¸€å¼€å§‹æƒ³åˆ°çš„æ˜¯ä¸­åºéå†ï¼Œå› ä¸ºä¸­åºéå†æœ‰ä¸ªç‰¹ç‚¹ï¼Œä»ä¸Šæ–¹æŠ•å½±ä¸‹æ¥å°±æ˜¯ä¸­åºéå†çš„ç»“æœï¼Œé‚£ä¹ˆæˆ‘åªè¦æ£€æŸ¥éå†ç»“æœæ˜¯ä¸æ˜¯é•œåƒçš„å°±è¡Œäº†ã€‚æ€è·¯æ˜¯å¯¹çš„ï¼Œä½†æ˜¯ç¬¬ä¸€æ¬¡æäº¤å°±æŠ¥é”™äº†ï¼ŒåŸå› æ˜¯ä¼šæœ‰ä¸‹é¢ä¸€ç§çŠ¶å†µï¼š  
```
     1
    / \
   2   3
  /    /
 3    2
è¿™ä¸ªçš„ä¸­åºéå†ä¹Ÿæ˜¯é•œåƒçš„ğŸ˜‚
```
è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ï¼Œæ£€æµ‹å·¦å³èŠ‚ç‚¹çš„æ•°é‡æ˜¯å¦ç›¸ç­‰ã€‚  
é—®é¢˜æ˜¯ä¸‹é¢çš„ä»£ç æ²¡æœ‰è¢«ACï¼Œç™¾æ€ä¸å¾—å…¶è§£ã€‚ã€‚ã€‚ä½†æˆ‘è·‘äº†äº›æµ‹è¯•éƒ½æ˜¯æ­£ç¡®çš„ã€‚
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        ArrayList<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();

        int leftcount = 0;
        int rightcount = 0;

        TreeNode curr = root;
        while (curr != null || !stack.isEmpty()) {
            while (curr != null) {
                stack.add(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            if (curr.left != null) leftcount++;
            if (curr.right != null) rightcount++;
            list.add(curr.val);
            curr = curr.right;
        }

        if (leftcount != rightcount) return false;

        String temp1 = "";
        for (Integer i : list) {
            temp1 += i;
        }
        String temp2 = "";
        for (int i = list.size() - 1; i >= 0; i--) {
            temp2 += list.get(i);
        }
        return temp1.equals(temp2);
    }
}
```

#### å…¶ä»–è§£æ³•  
æ¥è‡ªï¼šhttps://leetcode.com/discuss/18354/recursive-and-non-recursive-solutions-in-java  
Recursive--400ms:
```java
public boolean isSymmetric(TreeNode root) {
    return root==null || isSymmetricHelp(root.left, root.right);
}

private boolean isSymmetricHelp(TreeNode left, TreeNode right){
    if(left==null || right==null)
        return left==right;
    if(left.val!=right.val)
        return false;
    return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);
}
```
Non-recursive(use Stack)--460ms:

```java
public boolean isSymmetric(TreeNode root) {
    if(root==null)  return true;

    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode left, right;
    if(root.left!=null){
        if(root.right==null) return false;
        stack.push(root.left);
        stack.push(root.right);
    }
    else if(root.right!=null){
        return false;
    }

    while(!stack.empty()){
        if(stack.size()%2!=0)   return false;
        right = stack.pop();
        left = stack.pop();
        if(right.val!=left.val) return false;

        if(left.left!=null){
            if(right.right==null)   return false;
            stack.push(left.left);
            stack.push(right.right);
        }
        else if(right.right!=null){
            return false;
        }

        if(left.right!=null){
            if(right.left==null)   return false;
            stack.push(left.right);
            stack.push(right.left);
        }
        else if(right.left!=null){
            return false;
        }
    }

    return true;
}
```