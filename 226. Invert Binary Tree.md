## 226. Invert Binary Tree
Difficulty: Easy  
Invert a binary tree.

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

Trivia:
This problem was inspired by this original tweet by Max Howell:
Google: 90% of our engineers use the software you wrote (Homebrew), but you canâ€™t invert a binary tree on a whiteboard so fuck off.ğŸ˜‚
#### æˆ‘çš„æ€è·¯(not ACğŸ˜‚)
å…¶å®æˆ‘æ˜¯æƒ³åˆ°äº†å’Œ101é¢˜é•œåƒæ ‘å·®ä¸å¤šçš„æ€è·¯ï¼Œå°±æ˜¯é€’å½’å°†å¯¹ç§°çš„ä¸¤è¾¹çš„èŠ‚ç‚¹äº¤æ¢å€¼ï¼Œäº‹å®è¯æ˜åªé’ˆå¯¹`æ»¡äºŒå‰æ ‘`æœ‰æ•ˆã€‚
#### é€’å½’è§£æ³•
æ¥è‡ªhttps://leetcode.com/discuss/42059/my-simple-recursion-java-solution  
ä»¥é¢˜ç›®ä¸­çš„ä¾‹å­ä¸ºä¾‹ï¼Œè®¾æ–¹æ³•åinvertTreeåˆ«åfï¼š
```
tmp = 2;
4.left = f(7),
         f(7):tmp = 6,
              7.left = f(9),
                       f(9):tmp = null,
                            9.left = f(null) = null,
                            9.right = f(null) = null,
                            return 9; //å³7.left = 9
              7.right = f(6),
                        f(6):tmp = null,
                        6.left = f(null) = null,
                        6.right = f(null) = null,
                        return 6;
          return 7ï¼›
4.right = f(2),
          f(2): tmp = 1,
                2.left = f(3), 
                         f(3):tmp = null,
                              3.left = f(null) = null,
                              3.right = f(null) = null,
                              return 3;
                2.right = f(1),
                          f(1):tmp = null,
                          1.left = f(null) = null,
                          1.right = f(null) = null,
                          return 1;
          return 2ï¼›
return 4;

```

```java
public class Solution {
    //é€’å½’åˆ°æ ¹èŠ‚ç‚¹çš„æ—¶å€™ä¼šè¿”å›è‡ªå·±ï¼Œä¹Ÿå°±æ˜¯root
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(tmp);
        return root;
    }
}
```

#### éé€’å½’è§£æ³•
ä»¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹4ï¼Œä¸ºä¾‹ï¼š  
```
â†“ â†‘
4 4
node = 4
left = 2 
ç„¶åäº¤æ¢å·¦å³èŠ‚ç‚¹ï¼Œå˜æˆ
  4
 / \
7   2
```

```java
public class Solution {
    public TreeNode invertTree(TreeNode root) {

        if (root == null) {
            return null;
        }

        final Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);

        while(!stack.isEmpty()) {
            final TreeNode node = stack.pop();
            final TreeNode left = node.left;
            node.left = node.right;
            node.right = left;

            if(node.left != null) {
                stack.push(node.left);
            }
            if(node.right != null) {
                stack.push(node.right);
            }
        }
        return root;
    }
}
```